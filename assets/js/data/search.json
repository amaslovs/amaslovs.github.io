[ { "title": "Defining dependency scope within BackgroundService", "url": "/posts/defining-dependancy-scope/", "categories": "Web API", "tags": "webapi, netcore, backgroundservice", "date": "2024-10-02 06:00:00 +0300", "snippet": "IssueIn this blog post I’ll describe a situation I encountered in one of my projects, where I had to access an interface that was registered as a scoped service from BackgroundService, which is sin...", "content": "IssueIn this blog post I’ll describe a situation I encountered in one of my projects, where I had to access an interface that was registered as a scoped service from BackgroundService, which is singleton. In essence, I’ll describe a neat trick on how to access scoped service from singleton service.In the Program.cs of this example web app we have our initialization of builder and method that adds example service in a pattern I really like, split by features, which also makes it more readable. In this case AddExampleFeature() can contain various service descriptors for a given feature of a web app.var builder = WebApplication.CreateBuilder(args);builder.Services.AddExampleFeature()Then we have our given IServiceCollection method that defines lifecycle of example servicepublic static class IServiceCollectionExtension{ public static IServiceCollection AddExampleFeature(this IServiceCollection services) { services.AddScoped&lt;IRandomRepository, RandomRepository&gt;(); return services; }}If we would want to consume this given interface from BackgroundService which by design has a singleton lifecycle, we would run into an exception as scoped service cannot be consumed by singleton service. Application would thrown this exception:InvalidOperationException: Cannot consume scoped service 'Random.Path.ToFile.RandomRepository' from singleton 'Random.Path.ToBackgroundService.ExampleBackgroundService'.SolutionTo circumvent this we can pass IServiceProvider in the BackgroundService constructor and create a new IServiceScope within BackgroundService to resolve scoped service.public class ExampleBackgroundService( IServiceProvider provider) : BackgroundService{ protected override async Task ExecuteAsync(CancellationToken stoppingToken) { using var scope = provider.CreateScope(); { var randomRepository = scope.ServiceProvider.GetRequiredService&lt;IRandomRepository&gt;(); //do magic with your random repository } }}By utilizing the IServiceProvider extension method we can now play around with transient or scoped services within BackgroundService.Thank you for readingMore on IServiceProvider here: https://learn.microsoft.com/en-us/dotnet/api/system.iserviceprovider?view=net-8.0More on IServiceScope here: https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.serviceproviderserviceextensions.createscope?view=net-8.0More on DI and Lifecycles here: https://learn.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-8.0" }, { "title": "Using threading channels", "url": "/posts/threading-channels/", "categories": "Threading", "tags": "threading, netcore, channels, servicebus", "date": "2023-02-10 06:00:00 +0200", "snippet": "Idea behind…In one of my tasks I had a case where I had to use the same Azure ServiceBus message from one subscription in multiple Web API endpoints. One of these endpoints serves data on publish/s...", "content": "Idea behind…In one of my tasks I had a case where I had to use the same Azure ServiceBus message from one subscription in multiple Web API endpoints. One of these endpoints serves data on publish/subscribe basis and has to execute publish operation as soon as something new becomes available.SolutionIn order to utilize a single subscription in ServiceBus, a single reader was created for reading these messages that come on irregular basis. In order to serve incoming messages to the publish/subscribe endpoint and potentially any other listeners, some sort of distribution mechanism had to be put in place. For this task I chose Microsoft.Threading.Channels - a thread safe producer/consumer library. In short, System.Threading.Channels allows creation of Channel&lt;T&gt; property, which has ChannelWriter&lt;TWrite&gt; Writer and ChannelReader&lt;TRead&gt; Reader. In other words, Writer is used to write messages to Channel and Reader is used to access them. Channel is an object that stores written messages and allows reading them in “queue” like fashion.Implementation of System.Threading.Channels logic is quite straightforward. First, we have to define Channel itself, it can be Bound and Unbound. Bound channel has a specific capacity, which you have to set when initializing the channel. Unbound channels however do not have this capacity limitation. In my case I chose Bound channel, as my APIs require only the latest messages.public class ExampleDataModelChannel{ private readonly Channel&lt;ExampleDto&gt; _channel; public ExampleDataModelChannel() { _channel = Channel.CreateBounded&lt;ExampleDto&gt;( new BoundedChannelOptions(10) { AllowSynchronousContinuations = false, SingleReader = false, SingleWriter = false, FullMode = BoundedChannelFullMode.DropOldest }); } public ChannelReader&lt;ExampleDto&gt; Reader =&gt; _channel.Reader; public bool Publish(ExampleDto data) { return _channel.Writer.TryWrite(data); }}Given code allows me to write to Channel&lt;T&gt; using Publish whenever I instantiate ExampleDataModelChannel class._exampleDataModelChannel.Publish(model);and read utilizing Reader, as in example below.In this scenario, whenever a ServiceBus reader gets a new message it gets distributed to Channel&lt;T&gt;. To read the message, ChannelReader&lt;TRead&gt; Reader has to be utilized. So in order to notify subscribers from pub/sub API, a message would have to be served to them as soon as it becomes available in Channel&lt;T&gt;. Since logic that handles distributing messages to subscribed clients in my case runs as a separate BackgroundService, I’m able to read given Channel&lt;T&gt; and execute publish logic only when there is something to serve subscribed clients. protected override async Task ExecuteAsync(CancellationToken stoppingToken) { await foreach (var model in _dataChannel.Reader.ReadAllAsync(stoppingToken)) { try { //do magic here } catch (Exception e) { _logger.LogError(e, \"Something broke\"); } } }SummaryIn my particular case, I was able to utilize Microsoft.Threading.Channels for distributing ServiceBus messages in producer/consumer fashion across applications, as soon as ServiceBus reader receives them. Therefore not only allowing various reading scenarios for a single ServiceBus subscription message receiver, but also separating responsibility and logic outside the ServiceBus reader.More info on threading channels here: https://learn.microsoft.com/en-us/dotnet/core/extensions/channelsThank you for reading." }, { "title": "Defining Web API result", "url": "/posts/web-api-result-as/", "categories": "Web API", "tags": "webapi, netcore, mvcoptions", "date": "2022-10-27 06:00:00 +0300", "snippet": "In this blog I’m going to showcase how I handled a case when a customer required to have an endpoint which accepts XML object via POST and returns different XML object back.There are multiple ways ...", "content": "In this blog I’m going to showcase how I handled a case when a customer required to have an endpoint which accepts XML object via POST and returns different XML object back.There are multiple ways to go about this, but the main ones would be to declare what we expect and what we will return in the API controller itself by attributes. If given API only serves XML type responses we could do this in service builder as well.However, the first step in this case would be to tell Web API services that we will produce XML in the first place by adding Output formatter in Web API program.cs.var builder = WebApplication.CreateBuilder(args);ConfigureServices();void ConfigureServices(){ builder.Services.AddMvc(options =&gt; { options.OutputFormatters.Add(new XmlSerializerOutputFormatter( new XmlWriterSettings { OmitXmlDeclaration = false })); }).AddXmlSerializerFormatters();}After this, we can declare both, or either [Consumes()] and [Produces()] attributes in the controller. Consumes in this case would tell the Controller that we expect XML in the body. Produces however tells that result should be specified type, in this case XML.[HttpPost][Produces(\"application/xml\")][Consumes(\"application/xml\")]public IActionResult ExampleMethod(){ return Ok(\"fancy XML\");}To access consumed XML, in ASP.NET Core web API we can use parameter binding, like [FromBody], which looks like this.[HttpPost][Produces(\"application/xml\")][Consumes(\"application/xml\")]public IActionResult ExampleMethod([FromBody] XmlDocument request){ var result = _someInterface.DoSomething(request); return Ok(result);}As I mentioned in the beginning of this blogpost, we can also set Produces and Consumes in the service builder, in the same code block that declares output formatting.builder.Services.AddMvc(options =&gt;{ options.Filters.Add(new ProducesAttribute(\"application/xml\")); options.Filters.Add(new ConsumesAttribute(\"application/xml\")); options.OutputFormatters.Add(new XmlSerializerOutputFormatter(new XmlWriterSettings{OmitXmlDeclaration = false}));}).AddXmlSerializerFormatters();Then in the controller we don’t have to specify Produces and Consumesattributes.Thanks for reading this quick code snippet showcase. Happy coding!" }, { "title": "Creating Web API background service", "url": "/posts/web-api-backgroundservice/", "categories": "Web API", "tags": "webapi, netcore, backgroundservice", "date": "2022-10-06 06:00:00 +0300", "snippet": "In ASP.NET Core we can implement background tasks, or Hosted Services, that aid desired logic of a particular application.Previously I wrote about one potential use case of such background task her...", "content": "In ASP.NET Core we can implement background tasks, or Hosted Services, that aid desired logic of a particular application.Previously I wrote about one potential use case of such background task here.Since .NET Core 2.0 we can use IHostedService interface to easily implement hosted services for our applications. In the context of the given example I’m using the BackgroundService base class that implements the IHostedService interface. BackgroundService is located in the Microsoft.Extensions.Hosting package, which comes pre-installed when creating a new .NET Core Web API project.To create a background service in Web API from scratch, the first step is to create the desired background service class and inherit from the BackgroundService base class and implement the necessary ExecuteAsync method.public class ExampleService : BackgroundService{ protected override Task ExecuteAsync(CancellationToken stoppingToken) { throw new NotImplementedException(); }}Here within ExecuteAsync we can write all required logic for the new background service.In order for it to register to Host as a background task, we have to register it through AddHostedService method in Startup class.var builder = WebApplication.CreateBuilder(args);void ConfigureServices(){ builder.Services.AddHostedService&lt;ExampleService&gt;();}More detailed info about IHostedService here: https://learn.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/background-tasks-with-ihostedservice" }, { "title": "Web API with ServiceBus and caching", "url": "/posts/web-api-servicebus/", "categories": "Architecture", "tags": "webapi, netcore, servicebus", "date": "2022-10-06 06:00:00 +0300", "snippet": "Idea behind…In this blog post I’m going to showcase a neat way of preparing data for Web API, in cases when data comes from different application with the ability to have filtering applied. In this...", "content": "Idea behind…In this blog post I’m going to showcase a neat way of preparing data for Web API, in cases when data comes from different application with the ability to have filtering applied. In this particular case my project has Azure Webjob that produces data snapshot which has to be exposed in Web API. In addition to exposing, Web API also has to convert that snapshot from domain model to supported data format, in this case XML in specific standard.SolutionFirst problem is how could we pass data to the Web API in an efficient way, where Web API could always listen for any new data. Great solution for this is Azure ServiceBus, which allows us to subscribe to topics and listen for any new data. Where on the other side, WebJob or any other data provider can publish data to. Now, in order for the API to always have the latest data, ServiceBus listener has to be set as BackgroundService in Web API, so it’s always running - even if no one is requesting data from API itself.At this point Web API has a ServiceBus listener that always fetches the latest data from ServiceBus topic. If a data publisher, in this case WebJob, does not already serve data in supported data format, for example XML, data has to be converted from a given domain model. If there is any filtering of data required it can also be done beforehand. After data is ready, it could be cached.So what do we have? Web API with background service that always listens for latest data from ServiceBus. Whenever new data comes in, it gets prepared in required data format and cached. Whenever a user requests data from Web API, Web API controller calls some kind of internal service which accesses cache, and returns the latest cached data.SummaryIf possible, data preparation in background before user request, is a great way to minimize response times from Web API. Utilization of publish/subscribe, in this case Azure ServiceBus, and caching is one way of doing it.Thanks for reading and happy coding!" }, { "title": "Cross-App Application Insights", "url": "/posts/Cross-App-Telemetry/", "categories": "Architecture", "tags": "appinsights, telemetry, architecture", "date": "2022-09-20 20:00:00 +0300", "snippet": "Idea behind…Once there was an requirement to implement custom payment handling system that gets triggered from Web UI. Whenever all data was collected from the website, something had to be called t...", "content": "Idea behind…Once there was an requirement to implement custom payment handling system that gets triggered from Web UI. Whenever all data was collected from the website, something had to be called to process calling payment API endpoints, such as authorization, product loading, etc. Since at that time Azure was and currently is the go-to cloud provider for my project, choice of Azure infrastructure for such a task was made. But then question arose how could we log such data flow in detailed manner, so we could tie actions made in Web UI together with actions later done in for example Azure durable functions and view them in sequential order without heavy load. One neat way that came in mind is Azure Application Insights.Idea behind this is that a Web app would track every meaningful user action to Application Insights as the user was performing it, for example - selecting product categories. In addition to every meaningful action performed by the app itself, such as data query or storing would and could be tracked. Whenever actions of different app, for example Azure Functions, are required to finish process, that given app also can track every action to same Application insights using same unique identifier as Web app.Esentially every desired action could be tracked. Such tracking can be performed using custom event metrics. More info on custom event metrics: https://learn.microsoft.com/en-us/azure/azure-monitor/app/api-custom-events-metricsCode samplesFor this we need the Microsoft.ApplicationInsights package.In order for us to track same event sequence across multiple apps, we can use Operation Id which can be set up in Application Insights data model ( https://learn.microsoft.com/en-us/azure/azure-monitor/app/data-model-context ).Operation ID can be set up by accessing TelemetryClient context.For example such method can be created for ease of use across multiple apps:public class AppInsightsTelemetryService : IAppInsightsTelemetryService{ public void TrackEvent(string eventName, string operationId, Dictionary&lt;string, string&gt; properties = null) { var tc = new TelemetryClient(); if(!string.IsNullOrEmpty(operationId)) tc.Context.Operation.Id = operationId; tc.TrackEvent(string.IsNullOrEmpty(eventName) ? \"CustomEvent\" : eventName, properties); }}Then to call this method, we can specify eventName that would show up in Azure portal transaction search, as well as any properties we wish to pass along. Operation Id in this case has to be unique across the entire solution but same in each call you wish to track together with previous._telemetry.TrackEvent(\"Add Product\",cart.Data.Id.ToString(),new Dictionary&lt;string, string&gt; { { \"userName\", cart.Data.UserName }, { \"lineItems\", JsonConvert.SerializeObject(cart.Data.LineItems) }, { \"executionTime\", sw.Elapsed.ToString() } });Azure portalIn order to view Custom Events in Azure Portal, we would need to navigate to given Azure Application Insights instance and select Transaction search. There we can toggle desired Event types and select “Custom Events”. Additional filtering can be applied on top of that, were we can search for our custom operationId. Results will display all telemetry data with that Id in order they were logged, no matter from which App.Happy logging :)" } ]
